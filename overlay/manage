#! /usr/bin/perl -w


use FindBin;
use File::Spec;


use constant pristine_tree => "vendor";
use constant patched_tree => "patched";
use constant more_toplevel_excludes => qw/README usr/;


our($ROOT, $cfg_archive, $cfg_RCS);


{
   package directory;
   use Carp;
   
   
   sub name {
      return shift->{name};
   }


   sub fail {
      my($me, $msg)= @_;
      croak qq'$msg directory "' . $me->name . qq'": $!';
   }   

   
   sub new {
      my(undef, $name)= @_;
      my $me= bless {};
      local *DIR;
      opendir DIR, $me->{name}= $name or $me->fail("Could not open");
      $me->{dh}= *DIR{IO};
      return $me;
   }
   
   
   DESTROY {
      my $me= shift;
      if (my $dh= $me->{dh}) {
         closedir $dh or $me->fail("Could not close");
      }
   }
   
   
   sub read {
      die if wantarray;
      return readdir shift->{dh};
   }
}


{
   package file;
   use Carp;
   
   
   sub name {
      return shift->{name};
   }


   sub fail {
      my($me, $msg)= @_;
      croak qq'$msg file "' . $me->name . qq'": $!';
   }   

   
   sub new {
      my(undef, $mode, $name)= @_;
      my $me= bless {};
      local *FILE;
      open FILE, $mode, $me->{name}= $name or $me->fail("Could not open");
      $me->{fh}= *FILE{IO};
      return $me;
   }
   
   
   DESTROY {
      my $me= shift;
      if (my $fh= $me->{fh}) {
         close $fh or $me->fail("Could not close");
      }
   }
   
   
   sub readline {
      my $me= shift;
      my $line;
      die if wantarray;
      undef $!;
      unless (defined($line= readline $me->{fh})) {
         $me->fail("Error while reading from") if $!;
      }
      return $line;
   }
}


sub ensure_dir($) {
   my($rpath)= @_;
   -d $rpath && return;
   mkdir $rpath or die qq'Could not create directory "$rpath": $!';
   -d $rpath or die $!;
}


sub reconcile_file {
   my($orig, $ovl, $pchd, $live, $pfd)= @_;
   my $arch;
   if (defined $cfg_archive) {
      my($vol, $dirs1, $dirs2);
      ($vol, $dirs1)= File::Spec->splitpath($cfg_archive, 1);
      (undef, $dirs2, $arch)= File::Spec->splitpath($live);
      $arch= File::Spec->catpath(
         $vol, File::Spec->catdir($dirs1, $dirs2), $arch
      );
   }
   01 && print
        qq'ORIG "$orig", OVL "$ovl", PATCHED "$pchd", '
      . 'ARCHIVE "', $arch || '(null)' , '", '
      . qq'LIVE "$live", PATCHFILEDIR "$pfd".\n'
   ;
   undef $pfd if -l $pfd || ! -f _;
}


sub manage {
   my($basedir, $rpath, $exclusions)= @_;
   my(@d, $entry, $path, $abspath);
   $abspath= File::Spec->catdir($basedir, $rpath);
   {
      my $dh= new directory($abspath);
      while (defined($entry= $dh->read)) {
         next if exists $exclusions->{$entry};
         next unless File::Spec->no_upwards($entry);
         $path= File::Spec->catfile($abspath, $entry);
         if (-l $path || -f _) {
            reconcile_file
                  +(
                     map {
                          defined()
                        ? File::Spec->catfile(
                             File::Spec->catdir($basedir, $_, $rpath), $entry
                          )
                        : $path
                        ;
                     } pristine_tree, undef, patched_tree
                  )
               , File::Spec->catfile(
                    File::Spec->catdir($ROOT, $rpath), $entry
                 )
               , "$path.patches"
            ;
         } elsif (-d _) {
            push @d, $entry unless $entry =~ /.+\.patches$/;
         }
      }
   }
   foreach $entry (@d) {
      $path= File::Spec->catdir($rpath, $entry);
      foreach (patched_tree, pristine_tree) {
         ensure_dir +File::Spec->catdir($basedir, $_, $path);
      }
      &manage($basedir, $path, $exclusions);
   }
}


# Honor the ROOT variable from "/etc/make.conf".
$ROOT= qx{emerge --info | grep '^ROOT='};
$ROOT= qx{eval "$ROOT" && printf '%s' \$ROOT} || File::Spec->rootdir;
{
   # Determine config file path.
   use constant cfg_path => '/etc/dispatch-conf.conf';
   my($vol, $subdirs, $file)= File::Spec->splitpath(cfg_path);
   my $cfg= File::Spec->catfile(
        File::Spec->catdir(File::Spec->catpath($vol, $ROOT, ''), $subdirs)
      , $file
   );
   if (-f $cfg) {
      # Read config file.
      my $cfg= new file('<', $cfg);
      while (defined($_= $cfg->readline)) {
         $cfg_RCS= 1 if /^use-rcs\s*=\s*yes\s*$/i;
         if (/^archive-dir\s*=\s*(.+?)\s*$/i) {
            (undef, $cfg_archive)= File::Spec->splitpath($1, 1);
            my($vol, $root)= File::Spec->splitpath($ROOT, 1);
            $cfg_archive= File::Spec->catpath(
               $vol, File::Spec->catdir($root, $cfg_archive), ''
            );
         }
      }
   }
}
my $basedir= $FindBin::Bin;
foreach (pristine_tree, patched_tree) {
   ensure_dir +File::Spec->catdir($basedir, $_);
}
&manage(
     $basedir, File::Spec->curdir
     , {
        map {$_, undef}
          $FindBin::Script, more_toplevel_excludes
        , pristine_tree, patched_tree
     }
);
